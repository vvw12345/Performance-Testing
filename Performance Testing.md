# Performance Testing

本项目是个人学习协程知识的总结以及对一些常见的协程实现的性能测评……

## 协程

### 协程是什么？

#### 进程和线程

​	在引入协程之前，首先我们要知道进程和线程是什么？

​	进程，线程和协程是OS领域经常出现的名词，它们都是操作系统中的抽象概念，有联系和共同的地方，但也有区别。计算机的核心是 CPU，它承担了基本上所有的计算任务；而操作系统是计算机的管理者，它可以以进程，线程和协程为基本的管理和调度单位来使用 CPU 执行具体的程序逻辑。

​	从历史角度上看，它们依次出现的顺序是进程、线程和协程。在还没有进程抽象的早期操作系统中，计算机科学家把程序在计算机上的一次执行过程称为一个任务（Task）或一个工作（Job），其特点是任务和工作在其整个的执行过程中，不会被切换。这样其他任务必须等待一个任务结束后，才能执行，这样系统的效率会比较低。

​	在引入面向 CPU 的分时切换机制和面向内存的虚拟内存机制后，进程的概念就被提出了，**进程成为 CPU（也称处理器）调度（Scheduling）和分派（Switch）的对象，各个进程间以时间片为单位轮流使用 CPU，且每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。**这时，操作系统通过进程这个抽象来完成对应用程序在 CPU 和内存使用上的管理。

​	随着计算机的发展，对计算机系统性能的要求越来越高，而进程之间的切换开销相对较大，于是计算机科学家就提出了线程。**线程是程序执行中一个单一的顺序控制流程，线程是进程的一部分，一个进程可以包含一个或多个线程。各个线程之间共享进程的地址空间，但线程要有自己独立的栈（用于函数访问，局部变量等）和独立的控制流。且线程是处理器调度和分派的基本单位。**对于线程的调度和管理，可以在操作系统层面完成，也可以在用户态的线程库中完成。用户态线程也称为绿色线程（GreenThread）。如果是在用户态的线程库中完成，操作系统是“看不到”这样的线程的，也就谈不上对这样线程的管理了。

​	由此可见，进程和线程最根本的差异在于**地址空间**。线程的切换避免了切换地址空间的开销，从而使得调度更加的迅速。

#### 轻量级的线程——协程

​	正如标题所言，轻量级的线程就是协程吗？

​	前面我们说到线程的切换避免了切换地址空间的开销，那类比一下，协程要当`轻量级的线程`，是否意味着协程的切换避免了切换栈的开销呢？

​	很接近了！接下来不妨看一下是如何做到的。

​	你可以把协程理解为一种特殊的函数，特殊之处在哪里？一般的函数一旦被调用，只可以从头开始执行，直到执行结束之后退出。协程呢？可以执行到一半就可以退出（类似于进程和线程，只不过是主动的退出，称为`yield`），但此时该`函数`并没有真正地结束，只是暂时停止运行，让出CPU，后续又可以恢复执行（称为`resume`）。协程在`yield`和`resume`的时候和进程，线程一样，需要保存好`协程上下文`（其实就是相关的寄存器）。

​	那这些`协程上下文`我们保存到哪里去呢？一般来说有两种做法——有栈协程和无栈协程

##### 有栈协程

​	用独立的栈来保存协程的上下文信息。当协程`yield`时，当前的`协程上下文`会保存该栈上面。当协程被恢复的时候，又会从该栈上将之前保存的`协程上下文`恢复，从而从上次挂起的地方继续执行下去。

​	这种实现类似于内核态线程的实现，不同的协程之间切换还是要切换对应的协程上下文，省略了陷入内核的开销。

##### 无栈协程

​	不使用独立的栈来保存协程的上下文信息，而是把`协程上下文`放到公共内存中，当协程被挂起时， ⽆栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，⽆栈协程会将之 前保存的状态从堆中取出，并从上次挂起的地⽅继续执⾏。



## 异步编程性能测试

​	正如前文提到，协程是如此的高效。然而，协程只是现代异步编程其中一个概念。

​	市面上有许多对异步编程的支持，什么样的支持的性能会更加好呢？我们不妨在此进行一个测试（主要针对Rust和C++，当然其他的支持也非常优秀，但是我暂时没有学过……）。

### 队列调度测试

​	我们将对C++和Rust的协程/异步库进行队列调度的测试。

​	测评的场景如下：N个接收协程和N个发送协程（二者一对一）二者互发消息，消息的类型如下

- 整数(0:int)： 这种类型的消息，几乎不涉及内存分配
- 字符串(1:str)：这种类型的消息，是各语言默认的字符串复制，Rust 会有一次内存分配
- 字符串指针(2:str_ptr)：传递字符串的指针，几乎不涉及内存分配
- 字符串复制(3:str_clone): 传递时总是进行字符串内容的复制
- 浮点数：后续可能引入浮点数计算
- 结构体：包含不同类型字段的自定义结构



### 网络socket通信测试

​	本部分主要是对异步库实现的一些小型的WebServer进行性能测试，主要也是集中在Rust。









## 参考文献

- [rCore-Tutorial-Book-v3](https://rcore-os.cn/rCore-Tutorial-Book-v3)
- [浅谈有栈协程与无栈协程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/347445164)

