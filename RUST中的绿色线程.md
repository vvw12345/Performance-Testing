# RUST中的绿色线程

原作者：KEVIN ROSENDAHL

### 1 摘要

​	在这个项目中，我试图实现一个用Rust编写的绿色线程库，并提供尽可能与`std::thread`接口相似的界面。最具挑战性的部分是与Rust的接口实现这一点。相比于用C编写绿色线程库，在Rust中实现这一点非常困难。然而，一旦低级别实现完成，在Rust中工作要比在纯C中工作好得多。

​	最终，我成功创建了一个在Rust中工作的绿色线程库，并暴露了一个类似于`std::thread`的接口。在此过程中，我学习了Rust的外部函数接口（FFI）、闭包和其他数据类型的底层表示，并对Rust的编译时和运行时检查有了更深的理解。我还研究了可以构建在绿色线程之上的抽象，并将其与其他尝试解决类似问题的并发抽象进行了比较。

### 2 背景

#### 2.1 线程

​	在常见的并发模型中，最流行的历史上是线程。线程允许程序员编写可以并发执行的独立程序。主要有两种类型的线程：“原生”/“操作系统”线程和“绿色”线程。

​	“原生”或“操作系统”线程由程序运行的操作系统维护。这些线程通常会在多个CPU核心上多路复用，并且通常由操作系统抢占式调度。

​	抢占式调度意味着程序不必显式地放弃对另一个线程的控制。相反，操作系统本身会从正在运行的核心上取消调度线程并自动调度另一个线程。

​	另一方面，“绿色”线程不是由操作系统调度的，而是由在程序内部运行的运行时调度的。这有时被称为“用户级”线程（相对于“内核级”线程）。通常，这些线程是合作调度的。

​	合作调度是抢占式调度的对立面。在合作调度模型中，程序必须显式地从线程中放弃控制，通常返回到运行时，运行时然后决定下一个运行的线程。

#### 2.2 绿色线程在实际中的应用

​	绿色线程在许多语言中都有应用。目前最流行的绿色线程用法是Go的“goroutine”。Go实现了一个绿色线程运行时，可以在多个CPU核心上多路复用goroutines。然而，Go的运行时负责调度goroutines，程序不必显式地放弃控制。

​	事实上，Rust有使用绿色线程的历史。绿色线程运行时曾是Rust代码的默认模型。出于其他原因（将在本文后面讨论），Rust团队决定让一个系统语言使用绿色线程运行时并不合适。因此，他们决定放弃绿色线程运行时，转而使用原生线程。

#### 2.3 事件循环

​	另一种在主流编程语言中越来越受欢迎的并发模式是事件循环。事件循环注册了事件，并循环处理所有已通知事件循环的事件。一旦所有触发循环的事件都已处理完毕，事件循环重新开始，处理新触发的事件。

​	一个流行的事件循环示例是libuv，它构建了node.js。Rust也有一个流行的事件循环库mio，其上构建了tokio组件。

#### 2.4 异步I/O、回调、Futures、Promises和Async/Await

​	事件循环通常用于处理与异步I/O交互的多个不同任务。处理触发事件的一种方法是提供一个回调函数。这导致了通常称为“回调地狱”的情况，程序会演变成一系列不可解析的回调函数重定向。

​	为了应对“回调地狱”，创建了许多抽象。Futures提供了一个最终会解析为它包装的值的值。Promises和async/await语法试图将Futures包装起来，使代码看起来更像典型的过程式代码，而不是事件驱动的回调样式代码。

​	这些抽象风格的一个问题是它们仍然会泄露。图1展示了Rust中async/await的建议语法。一眼看上去，这看起来很好。返回类型是正常的返回类型，而不是Future或任何其他奇怪的类型。然而，进一步检查，我们发现函数必须标记为#[async]。实际上，所有调用fetch_rust_lang的函数都必须标记为#[async]。很快，你的整个程序都充满了async标记，每当你需要更改一个以前没有调用异步函数的函数时，你必须对其进行标记并标记每个调用它的函数。

#### 2.5 与CS242的关系

​	这个项目与CS242的课程和主题有很强的联系。正如我刚才概述的，选择编写程序的并发模型对语法、控制流和代码的一般感觉有着巨大的影响。

​	除了上述更主观但仍然非常重要的方面，选择的模型也会对应用程序的性能产生影响。稍后我们将讨论编写并发库时可以做出的不同设计选择如何影响运行时性能。

### 3 方法

#### 3.1 为什么要编写Rust绿色线程库？

​	编写一个Rust绿色线程库是我非常感兴趣的事情。去年在CS240课程中，我实现了一个非常基本的用C（和一些汇编）编写的绿色线程库作为实验的一部分。这让我对将来深入研究不同的并发技术产生了兴趣。我一直在开发node.js应用程序，已经厌倦了回调传递，并开始使用一个fibers库。

​	我对Rust已经有兴趣几年了。我发现它的静态分析和编译器保证以及其类型系统非常强大。然而，尽管我用Rust编写了一些玩具项目，但我还没有真正接触过在该语言中解决非平凡问题。编写一个Rust绿色线程库似乎是这两个兴趣的完美结合。

#### 3.2 上下文切换

​	绿色线程库的关键方面是上下文切换，即能够在一个绿色线程和另一个绿色线程之间切换执行控制流。

​	为此，你需要切换进入的上下文，并有一个地方存储你要切换出去的当前上下文。图2展示了表示这个的Rust结构体。

​	然后你可以使用指向这些结构体的指针作为我们汇编函数grn_context_switch的参数（见图3）。

​	然而，现在我们必须找到一种从Rust调用这个函数的方法。进入Rust的外部函数接口（FFI）。图4展示了我们在Rust中创建的函数，以便暴露我们的汇编函数。

​	这个Rust包装器，加上使用cc库的构建脚本，允许我们调用汇编函数grn_context_switch。这里需要注意的一件有趣的事情是ThreadContext结构体上的注解#[repr(C)]。这告诉Rust编译器它应该像C那样在内存中布局结构体，这样我们就可以像在grn_context_switch中那样使用结构体。

#### 3.3 线程栈

​	实现上下文切换需要对Rust的FFI、编译器、如何链接以及结构体的内存布局进行大量研究。尽管如此，这仍然是一个相当直接的实现。没有真正的设计决策需要做出。

​	一旦你有了上下文切换，下一步就是为最终的绿色线程创建一个栈。这听起来很简单：只需在堆上分配一些内存并称之为栈。然而，事实证明，根据你使用的栈分配和管理策略，有很多影响。

​	第一种栈风格就像普通的操作系统线程栈一样。你只需在堆上分配一块内存并将其用作栈。这种技术的主要好处是它的简单性。此外，如果一个线程最终使用了栈的大部分，你只需分配一次内存即可。

​	然而，许多时候程序希望使用绿色线程作为“轻量级任务”。为执行一个小任务分配一个相对较大的栈不会非常高效，如果生成许多绿色线程（这并不罕见），可能会导致程序使用大量内存。

​	为解决这个问题，使用了一种称为“分段栈”的技术。分段栈开始时很小（可能大约8KB，而不是2MB的常规栈）。当需要更多栈空间时，请求被捕获，并分配一个新的栈段，通过指针扩展栈。当不再需要额外空间时，释放新栈段。

​	除了维护不同栈段的显著复杂性外，使用分段栈时还可能出现一些陷阱。Rust和Go都开始使用分段栈编写运行时，后来都放弃了这种方式。Rust和Go的实现中共享的常见问题是所谓的“栈抖动”或“热点分裂”问题。

​	这个问题出现在程序中存在一个紧密循环，循环不断触及栈段边界时。在循环的每次迭代中，运行时必须分配一个新段，在迭代结束时，运行时必须释放新段。如果这发生在程序的一个足够关键部分，性能可能会急剧下降。

​	Go决定采取一个非常合理的方法来解决这个问题。Go的运行时现在将从一个小栈大小开始，类似于使用分段栈。然而，当goroutine用完栈时，运行时将分配一个新的、更大的（两倍大小）栈，并将原始栈内容复制到新栈。运行时还将分析栈的内容，并将指向旧栈的任何指针翻译为指向新栈的适当位置的指针。

​	Go做出了合理的权衡，如基准测试部分所示。我认为为我的库实现这样的方案超出了这个项目的范围，所以为了简单起见，我决定为每个新绿色线程静态分配一个2MB的栈。图5展示了ThreadStack结构体和构建器的使用。

#### 3.4 引导线程

​	现在我们能够切换上下文，并且选择了我们的栈管理策略，我们准备尝试实际运行一个绿色线程。

​	我原以为由于我之前在C绿色线程库上的工作，将解决方案移植到Rust会很简单。几个因素使得这个假设过于天真。第一个因素是Rust实际上不是C。虽然C允许你对任何数据做任何事情，但在Rust中你必须更加注意如何执行。第二个因素是我想编写一个易用的库。我之前编写的C库只接受静态函数指针。这使得实现非常简单，但大大降低了库的实用性。我希望我的Rust库可以实际使用。这至少意味着尝试匹配`std::thread`中提供的模式。图6展示了`std::thread::spawn`的签名。

​	简而言之，这个签名基本上表示它接收一个参数f，这是一个跨线程边界安全发送的闭包，返回一个类型T的值，该类型也可以跨线程边界安全发送。

​	引导绿色线程的一般技术是，一旦上下文已切换，就操纵栈指针值使控制跳转到一个跳板函数。绿色线程的初始栈也应被操纵，以便跳板函数可以找到应调用的函数的值并调用它。

​	在C中，这非常简单。图7展示了跳板函数。它期望在调用时栈顶部有应调用函数的地址。然后它调用该地址的函数，然后调用全局变量_grn_exit跳回C库并继续运行时。

​	图8展示了设置跳板函数的C代码。它只需将用户函数的地址放在栈的开头，将grn_bootstrap_thread的地址放在栈上，并将栈指针指向那里。

​	然而，在Rust库中我们没有让自己这么容易。我们遇到的第一个问题是我们接收的函数实际上不是函数指针，而是一个闭包trait对象。这意味着我们不能简单地获取这个值的地址，传递它，并稍后调用它。trait对象包含的不仅仅是函数，它还包含函数闭合的环境。

​	接下来的问题是我们不希望调用某个全局_grn_exit函数，我们希望调用在运行时结构体上负责跟踪活动绿色线程集合的方法。最终我们得到了以下结果。我们创建了一个新的全局函数call_fn（见图9）。这个函数接收两个void指针作为参数。然而，它然后将这些指针（本质上将它们转换回Rust的类型、安全方案）转换为指向指针到闭包的指针。第一个参数应指向用户的函数，第二个函数应指向负责在线程退出后委派回到运行时的闭包。图10展示了新的grn_bootstrap_thread实现，图11展示了一些栈位置和栈指针的设置。

​	Rust代码看起来很冗长，但很合理。然而，我在图11中包含的内容包含一个困扰我很久的bug。程序会正常运行，但在清理资源时崩溃。某种原因，Thread.stack.inner是一个空指针。图12展示了Thread结构体及其内存布局。正如所见，ThreadContext在ThreadStack的指针下方直接在地址空间中。ThreadContext.rsp特别是在ThreadStack指向的切片在堆上的指针之前7个字节。当我们将指针复制到栈上时，我们使用std::ptr::copy(src, dst, 8)。8是必要的，因为我们正在复制到[u8]，而在我们支持的平台（x86_64）上指针是8个字节长。然而，当我们使用相同的调用将bootstrap_thread_ptr复制到ThreadContext.rsp时，我们现在正在复制到一个u64。这会将值复制到ThreadContext.rsp和之后的7个8字节内存位置。最后一个位置是栈指针的位置，将其覆盖为0x0。由于我们的库实际上不触及栈，线程只使用它作为栈，运行时没有问题。然而，当我们去释放ThreadStack时，它的指针为空，程序崩溃。

​	我认为这个bug很好地突显了Rust试图实现的目标。C允许程序员尽情犯这个错误。然而，Rust让我努力地“射击自己脚”。虽然调试花费了比我希望的更多的时间和gdb，但我大致知道代码中问题所在。它必须在我用unsafe包装的地方之一。

#### 3.5 跨线程引用传递

​	我希望有一个负责生成、让步和清理线程的运行时结构体。图13展示了这些方法的基本轮廓。

​	如图11所示，我们调用spawn的回调只是self.exit。然而，正如我们在yield_now_to_status中进一步看到的，当让步和退出时需要进行大量的变异。然而，当我们实际消费库时，我们希望能够在任意数量的线程中调用yield_now。这将要求我们将运行时的可变引用传递给每个在绿色线程中运行的闭包。然而，Rust的借用检查器显然不允许这样做。

​	解决这个问题的答案是std::cell::RefCell。RefCell允许你将Rust的借用检查要求推迟到运行时。在这里我们知道一次只有一个线程在这些对象上操作，但Rust的编译器无法理解这一点。所以我们将运行时需要访问的所有成员包装在RefCell中，并调用borrow和borrow_mut来访问它们。图14展示了最终定义的运行时结构体。图15展示了yield_now_to_status的主体。

​	这里需要注意的一件有趣的事情是显式的块。在我重写的yield_now_to_status的初始尝试中没有包含显式的块，并会因为self.threads已被多次可变借用而恐慌。这是因为grn_context_switch会在临时借用的值的析构函数运行之前切换线程。这意味着临时借用的值从未释放其所有权，当下一个线程到达yield_now_to_status并尝试调用self.threads.borrow_mut时，它将其视为已被可变借用并恐慌。

### 4 结果

​	我完成了最初设定的任务：构建一个具有合理易用API的Rust绿色线程库。图16展示了一个示例程序及其输出。

​	我还能够尝试实现一些更高级的原语。特别是，我实现了一个sync函数，该函数运行一个绿色线程，但不要求调用函数显式调用yield_now。图17展示了使用sync的示例程序，图18展示了sync的实现。

​	我还希望编写一个异步I/O操作的包装器，以便能够比较绿色线程库与tokio的风格和速度。然而，我发现的每个异步I/O库似乎都与mio或其他范式紧密耦合，无法轻松集成到我的库中。

​	尽管如此，我将定性比较我创建的库与过去、现在和未来的Rust选项可能构建的抽象。

#### 4.1 libgreen

​	最初，Rust带有一个绿色线程运行时，但后来被删除，转而仅使用原生线程并在标准库中支持阻塞I/O。其原因如下：

- 强制共同演化：他们担心同时支持绿色和原生线程模型，并为它们支持相同的I/O API是一个不必要的负担，并且产生了最低公分母接口，而不是理想的接口。
- 开销：包括绿色线程运行时将“hello world”二进制文件的大小增加了一倍。
- 问题的I/O交互：并非所有用于绿色线程运行时的异步I/O函数实际上都是异步的。在绿色线程中进行阻塞调用可能会阻塞运行绿色调度程序的工作线程。
- 嵌入：从C或其他语言调用Rust代码时设置运行时需要大量工作。
- 维护负担：维护两个不同的实现很难。

​	我认为Rust团队在将运行时从Rust中删除并将其放入单独的库libgreen中是正确的选择。Rust旨在成为一种高性能的系统语言。它不应该将你逼入角落，使你无法获得最大的性能，并且绝对需要访问原生线程和原生API。

​	然而，我的库有一个巨大的优势：你今天可以实际使用它。libgreen三年多没有提交了，半年前Rust达到v1。在检查源代码时，你不会找到你知道的Rust，而是许多不同的复杂现已废弃的语法元素。

#### 4.2 tokio

​	tokio是一个大胆的尝试，旨在实现零成本抽象的异步I/O。要生成令人印象深刻的结果，你需要编写的代码字符总数很少，它包括了一些不错的Futures组合器。

​	tokio背后的技术工作是世界一流的，然而他们收到的主要投诉是“它令人困惑！”实际上，初始v0.1版本的发布被阻止，原因是需要向世界解释他们的异步抽象为何不令人困惑。他们目前的希望是Rust增加async/await语法将有所帮助。

#### 4.3 async/await

​	tokio面临的困境并不新鲜。最近，在node.js社区中也进行了同样的争论。四年前，每个人都在抱怨“回调地狱”，所以人们实现了Futures，并将它们包装在Promises中，世界欢欣鼓舞。但是，随后每个人都意识到他们讨厌Promises，于是他们决定你只需在异步函数之前写async，并在调用另一个异步函数时写await。

​	显式的async/await问题在于它像瘟疫一样传播。当你需要向函数添加异步I/O时，你必须在调用栈中弹出到处调用该函数的每个地方，标记调用await，并标记调用函数为async，依此类推。

​	所以虽然async/await在语法上可能比Futures和Promises更好，但仍然存在函数感染的潜在问题。这一问题在《你的函数是什么颜色》中得到了很好的总结。

#### 4.4 一种折中的选择

​	计算机科学就是关于权衡。Go有一个基于绿色线程的运行时，自动为你处理异步I/O。Rust有一个基于事件循环的异步I/O框架，可以产生一个可以处理多33%请求的http服务器，但没人能弄清楚如何使用它。

​	有没有一个正确的答案？当然没有。tokio应该绝对存在，并且应该旨在提供最有效的实现。希望async/await能够使其变得可以接受。对于许多系统语言来说，也许这就是我们想要停止的地方。

​	但是，我希望有一天看到Rust不仅被用作高性能系统语言，还作为一个符合人体工程学、开发者友好的通用编程语言。如果有一个绿色线程运行时能够自动处理异步I/O，你可以获得类似Go的性能，我完全可以看到它被用作这样的工具。但在那未来，我知道我自己不会尝试编写async tokio。

### 参考文献

1. 0000-remove-runtime. https://github.com/aturon/rfcs/blob/remove-runtime/active/0000-remove-runtime.md
2. Contiguous stacks. https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub
3. Rust Container Cheat Sheet. https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p
4. Trait Objects. https://doc.rust-lang.org/book/first-edition/ffi.html
5. Trait Objects. https://doc.rust-lang.org/book/first-edition/trait-objects.html
6. Zero-cost futures in Rust. https://aturon.github.io/blog/2016/08/11/futures/
7. alexcrichton. libgreen. https://github.com/alexcrichton/green-rs
8. alexcrichton. 2017. Restructure documentation from the ground up. https://github.com/tokio-rs/tokio/issues/13
9. Brian Anderson. 2013. Abandoning segmented stacks in Rust. https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html
10. laverdet. node-fibers. https://github.com/laverdet/node-fibers
11. Bob Nystrom. 2015. Restructure documentation from the ground up. http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/
12. CS240 Staff. Lab 1: Cooperative Green Threads. http://www.scs.stanford.edu/17sp-cs240/labs/lab1/
13. steveklabnik. 2015. Async IO. https://github.com/rust-lang/rfcs/issues/1081